목차 

[1. 싱글톤 패턴](#싱글톤 패턴)

[2. 팩토리 메소드패턴](#팩토리 메소드 패턴)

[3. 추상 팩토리 패턴](#추상 팩토리 패턴)

[4. 팩토리 메소드 vs 추상팩토리의 차이](#팩토리 메소드 vs 추상팩토리의 차이 )

[5. 빌더 패턴](#빌더 패턴)

[6. 프로토타입 패턴](#프로토타입 패턴)

[7. 어댑터 패턴](#어댑터 패턴)

[8. 브릿지 패턴](#브릿지 패턴)

[9. 컴포짓패턴](#컴포짓패턴)

[10. 데코레이터 패턴](#데코레이터 패턴)

[11. 퍼사트 패턴](#퍼사트 패턴)

[12. 플라이웨이트 패턴](#플라이웨이트 패턴)

[13. 프록시 패턴](#프록시 패턴)

[14. 책임 연쇄 패턴](#책임 연쇄 패턴)

[15. 커멘드 패턴](#커멘드 패턴)

[16. 인터프리터 패턴](#인터프리터 패턴)

[17.중재자 패턴](#중재자 패턴)

[18. 메멘토 패턴](#메멘토 패턴)

[19. 옵저버 패턴](#옵저버 패턴)

[20. 상태 패턴](#상태 패턴)

[21. 전략 패턴](#전략 패턴)

[22. 템플릿 메소드 패턴](#템플릿 메소드 패턴)

[22-1. 템플릿 콜백 패턴](#템플릿 콜백 패턴)
 
# 싱글톤 패턴 
## 인스턴스를 오직 한개만 제공하는 클래스 
- 시스템 런타임, 환경 셋팅에 대한 정보등, 인스턴스가 여러개 일 때 문제가 발생할 수 있는 경우가 있다. 이럴경우 인스턴스를 오직 한개만 만들어 제공하는 클래스
## 싱글톤 패턴 구현 방법 
- 동기화 `syhronized`를 사용해 멀티쓰레드 환경에 안전하게 만드는 방법 
- 이른 초기화`eager initialization` 을 사용하는 방법 
  - 단점 
    - 사용하지 않는 객체를 미리 만들어 두므로 쓸모없는 메모리를 사용한다.
- `double checked locking`으로 동기화 블럭 만들기 
  - `synchronized` 키워드를 메서드가 아닌 메서드내 에 추가하는 케이스
- static inner 클래스를 사용하는 방법 
- enum을 사용하는 방법
- 스프링 빈 스코프중에 하나로 싱글톤 스코프
- `java.lnag.Runtime`
- 빌더, 퍼사드, 추상팩토리등에 구현체에 쓰이기도 한다.

# 팩토리 메소드 패턴 
## 구체적으로 어떤 인스턴스를 만들지는 서브 클래스가 정한다.
- 다양한 구현체(Product)가 있고, 그 중에서 특정한 구현체를 만들 수 있는 다양한 팩토리(Creator)를 제공할 수 있다.
- OCP 원칙을 따른다. 
  - 확장에 열려 있고 변경에 닫혀 있는 객체 지향 원칙
  - 기존 코드를 변경하지 않고 새로운 기능을 추가(확장)할 수 있다.
- 장점
  - OCP 원칙을 따른다. 기존 코드를 건드리지 않고 새로운 인스턴스를 다른 방법으로 확장이 가능하다. 
  - product와 creator의 관계를 느슨하게 결합하기 때문에 OCP를 따를 수 있다.
- 단점
  - 역활을 나누다 보니 클래스의 갯수가 늘어난다.
- 자바8에 추가된 default 메서드에 대해 설명하세요.
  - 인터페이스에 기본 구현체를 만들 수 있는 기능 
- 자바9에 추가된 인터페이스의 private 메서드 기능 
  - 인터페이스에 private 메서드를 추가하여 사용할 수 있다.

- 단순한 팩토리 패턴 
  - 매개변수의 값에 따라 또는 메소드에 따라 각기 다른 인스턴스를 리턴하는 단순한 버전의 팩토리 패턴 
- java.lang.Calendar 또는 java.lang.NumberFormat
- 스프링의 BeanFactory
  - Object 타입이 Product를 만드는 BeanFactory라는 Creator!

# 추상 팩토리 패턴 
## 서로 관련 있는 여러 객체를 만들어 주는 인터페이스
- 구체적으로 어떤 클래스의 인스턴스를(concreate product)를 사용하는지 감출 수 있다.
- 추상클래스나 인터페이스로 정의하고 만드는건 팩토리랑 비슷하지만 클라이언트와 같이 봐야한다.
- Spring에서 FactoryBean

## 팩토리 메소드 vs 추상팩토리의 차이 
- 둘다 구체적인 객체 생성 과정을 추상화한 인터페이스 제공 
- 관점이 다르다.
  - 팩토리 메소드 패턴은 `팩토리를 구현하는 방법(inheritance)` 에 초점 
  - 추상 팩토리 패턴은 `팩토리를 사용하는 방법(composition)` 에 초점 
- 목적이 조금 다른다.
  - 팩토리 메소드 패턴은 구체적인 객체 생성 과정을 하위 또는 구체적인 클래스로 옮기는 것이 목적 
  - 추상 팩토리 패턴은 관련 있는 여러 객체를 구체적인 클래스에 의존하지 않고 만들 수 있게 해주는것이 목적

# 빌더 패턴
- 동일한 프로세스를 거쳐 다양한 구성의 인스턴스를 만드는 방법
- 복잡한 객체를 만드는 프로세스를 독립적으로 분리할 수 있다.
- 장점 
  - 만들기 복잡한 객체를 순차적으로 만들 수 있다.
  - 복잡한 객체를 만드는 구체적인 과정을 숨길 수 있다.
  - 동일한 프로세스를 통해서 각기 다른 객체를 만들 수 있다.
  - 불완전한 객체를 사용하지 못하도록 방지할 수 있다.
- 단점 
  - 원하는 객체를 만들려면 빌더부터 만들어야한다.
  - 구조가 복잡해 진다.(트레이드 오프)
- `StringBuilder`, `StringBuffer(멀티쓰레드)`
- `Stream.Builder API`
- `lombok @Bulder`
- 스프링 
  - `UriComponentsBuilder`
  - `MockMvcWebClientBuiler`..

# 프로토타입 패턴 
## 기존 인스턴스를 복제하여 새로운 인스턴스를 만드는 방법
- 복제 기능을 갖추고 있는 기존 인스턴스를 프로토타입으로 사용해 새 인스턴스를 만들 수 있다.
- 인스턴스를 만드는데 시간이 오래 걸리는 경우 기존에 만들어진 객체를 복사해서 새로운 인스턴스를 만든다. 
  - 디비 접속 
  - 네트워크 연결 
- `Objects.clone` 은  `Shallow copy` `얕은 복사`
- 장점
  - 복잡한 객체를 만드는 과정을 숨길 수 있다.
  - 기존 객체를 복제하는 과정이 새 인스턴스를 만드는 것보다 비용(시간 또는 메모리) 적인 면에서 효율적일 수 도 있다.
  - 추사적인 타입을 리턴할 수 있다.
- 단점 
  - 복제한 객체를 만드는 과정 자체가 복잡할 수 있다.(특히, 순환 참조가 있는 경우)
  - 참조하는 객체를 직접 구현할 수 도 있다.

# 어댑터 패턴
## 기존 코드를 클라이언트가 사용하는 인터페이스의 구현체로 바꿔주는 패턴 
- 클라이언트가 사용하는 인터페이스를 따르지 않는 기존 코드를 재사용할 수 있게 해준다.
- 타켓인터페이스를 직접 구현해주는 구현 클래스(어댑터)를 따로 만든다.
- OCP 원칙에 가까운 패턴 (확장에는 열려 있고 변경에는 닫혀 있다.)
- SRP 입장에서 보면 클래스를 나누는게 객체지향 기법에 가깝지만 실용적인 선택을 할때 적용할 수 있다.
- 장점 
  - 기존 코드를 변경하지 않고 원하는 인터페이스 구현체를 만들어 재사용 가능.
  - 기존 코드가 하던 일과 특정 인터페이스 구현체로 변환하는 작업을 각기 다른 클래스로 분리하여 관리할 수 있다.
- 단점
  - 새 클래스가 생겨 복잡도가 증가할 수 있다. 경우에 따라서는 기존 코드가 해당 인터페이스를 구현하도록 수정하는 것이 좋은 선택이 될 수도 있다.

# 브릿지 패턴 
## 추상적인 것과 구체적인 것을 분리하여 연결하는 패턴
- 하나의 계층 구조일 때 보다 각기 나누었을 때 독립적인 게층 구조로 발전 시킬 수 있다.
- 장점 
  - 추상적인 코드를 구체적인 코드 변경 없이도 독립적으로 확장할 수 있다.
  - 추상적인 코드와 구체적인 코드를 분리할 수 있다.
  - OCP, SRP 를 지킬 수 있다.
- 단점 
  - 게층 구조가 늘어나 복잡도가 증가 할 수 있다.

# 컴포짓패턴 
## 그룹 전체와 개별 객체를 동일하게 처리 할 수 있는 패턴 
- 클라이언트 입장에서는 전체나 부분이나 모두 동일한 컴포넌트로 인식할 수 있는 계층 구조를 만든다.
- 장점 
  - 복잡한 트리 구조를 편리하게 사용할 수 있다.
  - 다형성과 재귀를 활용할 수 있다.
  - 클라이언트 코드를 변경하지 않고 새로운 엘리먼트 타입을 추가할 수 있다.
- 단점 
  - 트리를 만들어야하 하기 때문에(공통된 인터페이스를 정의해야 하기 때문에) 지나치게 일반화 해야하는 경우도 생길 수 있다.

# 데코레이터 패턴
## 기존 코드를 변경하지 않고 부가 기능을 추가하는 패턴
- 상속이 아닌 위임을 사용해서 보다 유연하게(런타임에) 부가 기능을 추가하는 것도 가능하다.

![데코레이터패턴 객체 관계도](https://user-images.githubusercontent.com/310264/201913673-b55dec71-e90e-4d90-892d-5663079e3f44.png)

- 장점 
  - 새로운 클래스를 만들지 않고 기존 기능을 조합할 수 있다.
  - 컴파일 타임이 아닌 런타임에 동적으로 기능을 변경할 수 있다.
  - SRP 
  - OCP 
  - DI 
- 단점 
  - 데코레이터를 조합하는 코드가 복잡할 수 있다.


# 퍼사트 패턴
## 복잡한 서브 시스템 의존성을 최소화하는 방법 
- 클라이언트가 사용해야 하는 복잡한 서브 시스템 의존성을 간단한 인터페이스로 추상화 할 수 있다.

- 장점 
  - 서브 시슽메에 대한 의존성을 한곳으로 몰아 둘 수 있다.
- 단점 
  - 퍼사드 클래스가 서브 시스템에 대한 모든 의존성을 가지게 된다.

<img src="https://user-images.githubusercontent.com/310264/202069451-1497e1ef-70db-4aae-bbdb-0a465917c70d.png" width="200" height="300" />

# 플라이웨이트 패턴 
## 객체를 가볍게 만들어 메모리 사용을 줄이는 패턴 
- 자주 변하는 속성(또는 외적인 속성, extrinsit)과 변하지 않는 속성(또는 내적인 속성 instrinsit)을 분리하고 재사용하여 메모리 사용을 줄일 수 있다.

- 장점 
  - 애플리케이션에서 사용하는 메모리를 줄일 수 있다.
- 단점 
  - 코드의 복잡도가 증가한다.

# 프록시 패턴
## 특정 객체에 대한 접근을 제어하거나 기능을 추가할 수 있는 패턴
- 초기화 지연, 접근제어, 로깅, 캐쉬등 다양하게 응용해 사용 할 수 있다.
- 장점 
  - 기존 코드를 변경하지 않고 새로운 기능을 추가할 수 있다. (OCP)
  - 기존 코드가 해아 하는 일만 유지할 수 있다.(SRP)
  - 기능 추가 및 초기화 지연 등으로 다양하게 활용할 수 있다.
- 단점 
  - 코드의 복잡도가 증가한다.
- 자바 
  - 다이나믹 프록시, java.lang.reflect.Proxy
- 스프링
  - 스프링 AOP

# 책임 연쇄 패턴
## 요청을 보내는 쪽(sender)과 요청을 처리하는 쪽(receiver)의 분리하는 패턴 
- 핸들러 체인을 사용해서 요청을 처리한다.
![클래스 구조](https://user-images.githubusercontent.com/310264/202166205-de8039a5-21b1-4938-8a57-6063bb92b31c.png)
- 장점 
  - 클라이언트 코드를 변경하지 않고 새로운 핸들러를 체인에 추가할 수 있다.(SRP)
  - 각각의 체인은 자신이 해야하는 일만 한다.
  - 체인을 다양한 방법으로 구성할 수 있다.  
- 단점 
  - 디버깅이 조금 어렵다.
- java 
  - servlet doFilter
- spring
  - security

# 커멘드 패턴 
## 요청을 캡슐화 하여 호출자(invoker)와 수신자(recevier)를 분리하는 패턴 
- 요청을 처리하는 방법이 바뀌더라도, 호출자의 코드는 변경되지 않는다.
![커맨드패턴](https://user-images.githubusercontent.com/310264/202179966-ad345651-b957-4e29-9ff6-c654498ea877.png)
- 장점 
  - 기존 코드를 변경하지 않고 새로운 커맨드를 만들 수 있다.
  - 수신자의 코드가 변경되어도 호출자의 코드는 변경되지 않는다.
  - 커맨드 객체를 로깅, DB에 저장, 네트워크로 전송 하는 등 다양한 방법으로 활용할 수 있다.
- 단점 
  - 코드가 복잡하고 클래스가 많아진다.

# 인터프리터 패턴 
## 자주 등장하는 문제를 간단한 언어로 정의하고 재사용하는 패턴 
- 반복되는 문제 패턴을 언어 또는 문법으로 정의하고 확장할 수 있다.
![인터프래터패턴](https://user-images.githubusercontent.com/310264/202615474-92732500-4a8e-49a3-89da-16d56cf539d7.png)
- 장점 
  - 자주 등장하는 문제 패턴을 언어와 문법으로 정의할 수 있다.
  - 기존 코드를 변경하지 않고 새로운 Expression을 추가할 수 있다.
- 단점
  - 복잡한 문법을 표현하려면 Expression과 Parser가 복잡해진다.

# 이터레이터 패턴 
## 내부 구현을 들어내지 않고 집합객체를 외부 클라이언트가 순회하는 패턴
- 집합 객체를 순회하는 클라이언트 코드를 변경하지 않고 다양한 순회 방법을 제공할 수 있다.
![이터레이터패턴](https://user-images.githubusercontent.com/310264/202644765-de2e54e1-0778-4096-a7d7-4232a0efa024.png)
- 모든 순회과정을 iterator로 사용할 필요는 없다.
- 장점 
  - 집합 객체에 손쉽게 접근 할 수 있다.(집합 객체의 구조를 몰라도 된다.)
  - SRP
  - OCP
- 단점 
  - 클래스가 늘어나고 복잡도가 증가한다.
- 자바 
  - java.utils.Enumeration과 java.util.Iterator
  - java StAX(Streaming API for XML)의 Iterator 기반 API
    - XmlEventReader, XmlEventWrite
- 스프링
  - Compositelterator

# 중재자 패턴 
## 여러 객체들이 소통하는 방법을 캡슐화하는 패턴 
- 여러 컴포넌트간의 결합도를 중재자를 통해 낮출 수 있다.
![중재자패턴](https://user-images.githubusercontent.com/310264/202837245-18607af7-c925-4f11-bed5-5555031faa21.png)
- 장점 
  - 컴포넌트 코드를 변경하지 않고 새로운 중재자를 만들어 사용할 수 있다.
  - 각각의 컴포넌트 코드를 보다 간결하게 유지할 수 있다.
- 단점 
  - 중재자 역활을 하는 클래스의 복잡도와 결합도가 증가한다.
- 자바
  - ExecutorService 
  - Executor
- 스프링
  - DispatcherServlet

# 메멘토 패턴 
## 캡슐화를 유지하면서 객체 내부 상태를 외부에 저장하는 방법 
- 객체 상태를 외부에 저장했다가 해당 상태로 다시 복구할 수 있다.
![메멘토패턴](https://user-images.githubusercontent.com/310264/202838310-7efdf235-b82e-48f6-ae50-5878c090fa43.png)
- 장점 
  - 객체 내부의 상태를 외부에 노출하지 않고도 캡슐화 해서 객체 상태를 스냅샵을 할 수 있다.
  - 객체 생태 저장하고 또는 복원하는 역활을 CaseTaker에게 위임할 수 있다.
  - 객체 상태가 바뀌어도 클라이언트 코드가 변경되지 않는다.
- 단점
  - 많은 정볼르 저장하는 Mementor를 자주 생성하는 경우 메모리 사용량에 많은 영향을 줄 수 있다.

# 옵저버 패턴 
## 다수의 객체가 특정 객체 상태 변화를 감지하고 알림을 받는 패턴 
- 발행(publish)-구독(subscribe)패턴을 구현할 수 있다
![옵저버패턴](ttps://user-images.githubusercontent.com/310264/202886766-3557cf29-dc0c-4284-920b-03175c53cb42.png)
- 장점 
  - 상태를 변경하는 객체와 변경을 감지하는 객체의 관계를 느슨하게 유지할 수 있다
  - subject의 상태 변경을 주기적을 조회하지 않고 자동으로 감지할 수 있다
  - 런타임에 옵저버를 추가하거나 제거할 수 있다
- 단점 
  - 복잡도가 증가한다 
  - 다수의 observer 객체를 등록 이후 해지 않는다면 memory leak 이 발생할 수 있다

# 상태 패턴
## 객체 내부 상태 변경에 따라 객체의 행동이 달라지는 패턴
- 상태에 특화된 행동들을 분리해 낼 수 있으며, 새로운 행동을 추가하더라도 다른 행동에 영향을 주지 않는다.
![상태패턴](https://user-images.githubusercontent.com/310264/202890849-b23510a7-ed24-4b29-97b3-2beb2ba6be1c.png)
- 장점 
  - 상태에 따른 동작을 개별 클래스로 옮겨서 관리할 수 있다.
  - 기존의 특성 상태에 따른 동작을 변경하지 않고 새로운 상태에 다른 동작을 추가할 수 있다.
  - 코드 복잡도를 줄일 수 있다.
- 단점 
  - 복잡도가 증가한다.

# 전략 패턴 
## 여러 알고리즘을 캡슐화하고 상호 교환 가능하게 만드는 패턴 
- 컨텍스트에서 사용할 알고리즘을 클라이언트가 선택한다.
![전략패턴](https://user-images.githubusercontent.com/310264/202892070-49bfd472-2724-4315-9874-c1e740a992e2.png)
- 장점 
  - 새로운 전략을 추가하더라도 기존 코드를  변경하지 않느다.
  - 상속 대신 위임을 사용할 수 있다.
  - 런타임에 전략을 변결 할 수 있다.
- 단점 
  - 복잡도가 증가한다.
  - 클라이언트 코드가 구체적인 전략을 알아야 한다.

# 템플릿 메소드 패턴 
## 알고리즘 구조를 서브 클래스가 확장할 수 있도록 템플릿으로 제공하는 방법 
- 추상 클래스는 템플릿을 제공하고 하위 클래스는 구체적인 알고리즘을 제공한다.
![템플릿메소드패턴](https://user-images.githubusercontent.com/310264/202945085-589cc40b-fd56-48e5-b6f3-f16e9ee5c28f.png)
- 장점 
  - 템플릿 코드를 재사용하고 중복 코드를 줄일 수 있다
  - 템플릿 코드를 변경하지 않고 상속을 받아서 구체적인 알고리즘만 변경 할 수 있다
- 단점
  - 리스코프 치환 원칙을 위반할 수 있다
  - 알고리즘 구조가 복잡할 수록 템플릿을 유지하기 어려워진다.

- 리스코프 치환 원칙 
  - 상속 구조에서 상위 클래스 타입으로 사용하는 코드에서 그 코드를 상위타입 말고 상속받은 모든 클래스로 바꾸더라도 의도한데로 동작해야한다.
- 자바
  - HttpServlet.doGet ...goPost...
- 스프링
  -  SecurityConfigurer.init

# 템플릿 콜백 패턴 
## 콜백으로 상속 대신 위임을 사용하는 템플릿 패턴 
- 상속 대신 익명 내부 클래스 또는 람다 표현식을 활용할 수 있다.
![템플릿 콜백 패턴](https://user-images.githubusercontent.com/310264/202946080-4fa60483-8ff4-4e46-9c30-e0faf189ecd8.png)
